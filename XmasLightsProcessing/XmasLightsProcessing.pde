//Libraries
import controlP5.*;//gui
import processing.serial.*;//default
import cc.arduino.*;//arduino
import ddf.minim.analysis.*;//audio
import ddf.minim.*;//audio

//Constant Declaration
Serial serial;//Serial Monitor
Arduino arduino;//Arduino Controller
Minim minim;//Audio Processor
AudioInput in;//Audio Input
FFT fft;//Frequency Analyzer
ControlP5 cp5;//GUI Controller

//Arduino Variables
int relay1=2;
boolean relay1TF=false;
int relay2=3;
boolean relay2TF=false;
int outputs[]={relay1,relay2};
boolean outputsTF[]={relay1TF,relay2TF};
boolean audioActive=true;
boolean sleepActive=false;

//Audio Variables
float valScale = 1.0;
float maxVisible = 10.0;
float beatThreshold = 0.25;
float colorOffset = 30;
float autoColorOffset = 0.01;
float[] lastVal;
int buffer_size=1024;
float sample_rate=44100;

//Sleep Variables
int hour;
int minute;
int totalSeconds;

//Display Variables
int lastWidth=1000;
int lastHeight=600;
boolean fullscreen = false;

//Misc Variables
int counter=0;
int leftBorder()   {
  return int(.05 * width); 
}
int rightBorder()  {
  return int(.05 * width);
  }
int bottomBorder() {
  return int(.05 * width); 
}
int topBorder()    {
  return int(.05 * width); 
}

//GUI Code
public void textfield1_change1(GTextField source, GEvent event) { //_CODE_:Hour:640672:
  println("Hour - GTextField event occured " + System.currentTimeMillis()%10000000 );
} //_CODE_:Hour:640672:

public void textfield2_change1(GTextField source, GEvent event) { //_CODE_:Minute:871063:
  println("Minute - GTextField event occured " + System.currentTimeMillis()%10000000 );
} //_CODE_:Minute:871063:

public void dropList1_click1(GDropList source, GEvent event) { //_CODE_:AM_PM:699618:
  println("AM_PM - GDropList event occured " + System.currentTimeMillis()%10000000 );
} //_CODE_:AM_PM:699618:

public void checkbox1_clicked1(GCheckbox source, GEvent event) { //_CODE_:SleepCheck:477023:
  println("SleepCheck - GCheckbox event occured " + System.currentTimeMillis()%10000000 );
} //_CODE_:SleepCheck:477023:
public void textarea1_change1(GTextArea source, GEvent event) { //_CODE_:Timer:318342:
  println("textarea1 - GTextArea event occured " + System.currentTimeMillis()%10000000 );
} //_CODE_:Timer:318342:

// Create all the GUI controls. 
// autogenerated do not edit
public void createGUI(){
  G4P.messagesEnabled(false);
  G4P.setGlobalColorScheme(GCScheme.BLUE_SCHEME);
  G4P.setCursor(ARROW);
  Hour = new GTextField(this, 100, 100, 80, 22, G4P.SCROLLBARS_NONE);
  Hour.setDefaultText("Hour");
  Hour.setOpaque(true);
  Hour.addEventHandler(this, "textfield1_change1");
  Minute = new GTextField(this, 200, 100, 80, 22, G4P.SCROLLBARS_NONE);
  Minute.setDefaultText("Minute");
  Minute.setOpaque(true);
  Minute.addEventHandler(this, "textfield2_change1");
  AM_PM = new GDropList(this, 300, 100, 80, 44, 2);
  AM_PM.setItems(loadStrings("AM_PM.txt"), 0);
  AM_PM.addEventHandler(this, "dropList1_click1");
  SleepCheck = new GCheckbox(this, 100, 150, 120, 20);
  SleepCheck.setTextAlign(GAlign.LEFT, GAlign.MIDDLE);
  SleepCheck.setText("Sleep Timer");
  SleepCheck.setOpaque(false);
  SleepCheck.addEventHandler(this, "checkbox1_clicked1");
  TimerBox = new GTextArea(this, 100, 200, 160, 80, G4P.SCROLLBARS_NONE);
  TimerBox.setOpaque(true);
  TimerBox.addEventHandler(this, "textarea1_change1");
}

//GUI Objects
GTextField Hour; 
GTextField Minute; 
GDropList AM_PM; 
GCheckbox SleepCheck;
GTextArea TimerBox;

void setup() {
  size(1000,600);//creates a window size 1000x600
  PFont font = createFont("arial",20);
  cp5=new ControlP5(this);//sets a new controller for the gui
  cp5.addTextfield("Hours")
     .setPosition(200,100)
     .setSize(200,40)
     .setFont(font)
     .setFocus(true)
     .setText("00:");
     ;
     cp5.addTextfield("Minutes")
     .setPosition(200,100)
     .setSize(200,40)
     .setFont(font)
     .setFocus(true)
     .setText("00:");
     ;
     cp5.addTextfield("Seconds")
     .setPosition(200,100)
     .setSize(200,40)
     .setFont(font)
     .setFocus(true)
     .setText("00");
     ;
  frame.setResizable(true);//allows the size to be changed
   background(255,250,255);//sets background to white
   createGUI();
   minim=new Minim(this);//creates a new audio object
   in = minim.getLineIn(Minim.MONO,buffer_size,sample_rate);//creates an audio input
   fft = new FFT(in.bufferSize(), in.sampleRate());//creates a frequency analyzer
   fft.logAverages(16, 2);//create a smallest average frequency of 8
   fft.window(FFT.HAMMING);
   lastVal = new float[fft.avgSize()];
  //Intializing Arduino
   //arduino = new Arduino(this, Arduino.list()[0], 57600); //creates a new arduino object so it can communicate with the physical arduino
   //serial=new Serial(this, Serial.list()[0],4800);//creats a serial object so it can read data to the serial
  //for (int i = 0; i <= 13; i++)
    //arduino.pinMode(i, Arduino.OUTPUT);
    
}

void draw() {
  
    // Detect resizes
    if(width != lastWidth || height != lastHeight)
    {
      lastWidth = width;
      lastHeight = height;
      background(0);
      initLasts();
      println("resized");
    }
    
    fft.forward(in.mix);//Steps forward int the audio
    if(audioActive)
      audioAnalyze();
     if(SleepCheck.isSelected())
       sleepActive=true;
      else sleepActive=false;
     if(sleepActive)
       sleepAnalyze();
    // Display the frame rate
    fill(16, 16, 16);
    if(!fullscreen)
    {
    frame.setTitle("Christmas Tree Lights");
    }

}
void audioAnalyze(){
  int iCount = fft.avgSize();//Number of Averages being calculated
    float biggestValChange = 0;//Biggest Change from pervious 
    
    for(int i = 0; i < iCount; i++) {//Loops through all the audio averages
      
      float iPercent = 1.0*i/iCount;//Percentage of Audio Analyzed
      
      float highFreqscale = 1.0 + pow(iPercent, 4) * 2.0;//Gets the Frequency Range of the current step
      
      float val = sqrt(fft.getAvg(i)) * valScale * highFreqscale / maxVisible;
      float valDiff = val-lastVal[i];
      if(valDiff > beatThreshold && valDiff > biggestValChange)
      {
        biggestValChange = valDiff;
      }
      
      lastVal[i] = val;

    }
    
    // If we've hit a beat, bring the brightness of the bar up to full
    if(biggestValChange > beatThreshold)
    {
      //toggleOutput(0);
      //toggleOutput(1);
      print("Beat");
      if(counter==1){
      background(51);
      counter=0;
      }
      else{
        counter++;
        background(1000);
      }
    }
}
void sleepAnalyze(){
  setTime();
  int currentTime=timeToSeconds(hour(),minute(),second());
  int secondsLeft=totalSeconds-currentTime;
  int hoursLeft=secondsLeft/3600;
  int minutesLeft=secondsLeft%3600/60;
  int secondsLeft=secondsLeft%3600%60;
  TimerBox.setText(hoursLeft+":"+minutesLeft+":"+secondsLeft);
  if(hoursLeft==0&&minutesLeft==0&&secondsLeft==0){
    for(int i=0;i<outputsTF.length;i++){
      if(!outputsTF[i]){
        //toggleOutput(outputsTF[i]);
      }
    }
    audioActive=false;
    
  }
}
  int timeToSeconds(int hour, int minute, int second){
    return hour*3600+minute*60+second;
  }
  
void setTime(){
  int givenHour=Integer.parseInt(Hour.getText());
  int givenMinute=Integer.parseInt(Minute.getText());
  minute=givenMinute;
  if(AM_PM.getSelectedText().equals("PM")){
    hour=givenHour+12;
  }
  else hour=givenHour;
  int totalSeconds=timeToSeconds(hour,minute,0);
}
void initLasts(){
  for(int i = 0; i < fft.avgSize(); i++) {
    lastVal[i] = 0;
  }
  
}
void stop(){//properly closes the program 
  in.close();
  minim.stop();
  super.stop();
}
void toggleOutput(int reference){ //toggles an output at a specfic spot in the outputs array
   if(outputsTF[reference]==false)
    outputsTF[reference]=true;
  else if(outputsTF[reference]==true)
    outputsTF[reference]=false;
    arduino.digitalWrite(outputs[reference], outputs[reference]);
}


