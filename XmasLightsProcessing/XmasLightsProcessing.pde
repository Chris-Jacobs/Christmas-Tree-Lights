
//Libraries
import controlP5.*;//gui
import processing.serial.*;//default
import cc.arduino.*;//arduino
import ddf.minim.analysis.*;//audio
import ddf.minim.*;//audio

//Constant Declaration
Serial serial;//Serial Monitor
Arduino arduino;//Arduino Controller
Minim minim;//Audio Processor
AudioInput in;//Audio Input
FFT fft;//Frequency Analyzer
ControlP5 cp5;//GUI Controller


//Arduino Variables
int high=5;
int low=0;
int relay1=2;
boolean relay1TF=false;
int outputs[]={relay1};
boolean outputsTF[]={relay1TF};
boolean audioActive=true;
boolean sleepActive=false;
boolean timerUp=false;
//Audio Variables
float valScale = 1.0;
float maxVisible = 10.0;
float beatThreshold = 0.25;
float colorOffset = 30;
float autoColorOffset = 0.01;
float[] lastVal;
int buffer_size=1024;
float sample_rate=44100;

//Sleep Variables
int hour;
int minute;
int totalSeconds;

//Display Variables
int lastWidth=1000;
int lastHeight=600;
PImage tree;
boolean fullscreen = false;
boolean bgYellow
//Misc Variables
int counter=0;
int leftBorder()   {
  return int(.05 * width); 
}
int rightBorder()  {
  return int(.05 * width);
  }
int bottomBorder() {
  return int(.05 * width); 
}
int topBorder()    {
  return int(.05 * width); 
}

//GUI Code
public void textfield1_change1(GTextField source, GEvent event) { //_CODE_:Hour:640672:
  println("Hour - GTextField event occured " + System.currentTimeMillis()%10000000 );
} //_CODE_:Hour:640672:

public void textfield2_change1(GTextField source, GEvent event) { //_CODE_:Minute:871063:
  println("Minute - GTextField event occured " + System.currentTimeMillis()%10000000 );
} //_CODE_:Minute:871063:

public void dropList1_click1(GDropList source, GEvent event) { //_CODE_:AM_PM:699618:
  println("AM_PM - GDropList event occured " + System.currentTimeMillis()%10000000 );
} //_CODE_:AM_PM:699618:

public void checkbox1_clicked1(GCheckbox source, GEvent event) { //_CODE_:SleepCheck:477023:
  println("SleepCheck - GCheckbox event occured " + System.currentTimeMillis()%10000000 );
} //_CODE_:SleepCheck:477023:
public void textarea1_change1(GTextArea source, GEvent event) { //_CODE_:Timer:318342:
  println("textarea1 - GTextArea event occured " + System.currentTimeMillis()%10000000 );
} //_CODE_:Timer:318342:
public void checkbox1_clicked2(GCheckbox source, GEvent event) { //_CODE_:SoundCheck:569093:
  println("checkbox2 - GCheckbox event occured " + System.currentTimeMillis()%10000000 );
} //_CODE_:SoundCheck:569093:
public void button1_click1(GButton source, GEvent event) { //_CODE_:Reset:362161:
  println("Reset - GButton event occured " + System.currentTimeMillis()%10000000 );
  initLasts();
} //_CODE_:Reset:362161:
// Create all the GUI controls. 
// autogenerated do not edit
public void createGUI(){
  G4P.messagesEnabled(false);
  G4P.setGlobalColorScheme(GCScheme.BLUE_SCHEME);
  G4P.setCursor(ARROW);
  Hour = new GTextField(this, 100, 100, 80, 22, G4P.SCROLLBARS_NONE);
  Hour.setDefaultText("Hour");
  Hour.setOpaque(true);
  Hour.addEventHandler(this, "textfield1_change1");
  Minute = new GTextField(this, 200, 100, 80, 22, G4P.SCROLLBARS_NONE);
  Minute.setDefaultText("Minute");
  Minute.setOpaque(true);
  Minute.addEventHandler(this, "textfield2_change1");
  AM_PM = new GDropList(this, 300, 100, 80, 44, 2);
  AM_PM.setItems(loadStrings("AM_PM.txt"), 0);
  AM_PM.addEventHandler(this, "dropList1_click1");
  SleepCheck = new GCheckbox(this, 100, 150, 120, 20);
  SleepCheck.setTextAlign(GAlign.LEFT, GAlign.MIDDLE);
  SleepCheck.setText("Sleep Timer");
  SleepCheck.setOpaque(false);
  SleepCheck.addEventHandler(this, "checkbox1_clicked1");
  TimerBox = new GTextArea(this, 100, 200, 160, 80, G4P.SCROLLBARS_NONE);
  TimerBox.setOpaque(true);
  TimerBox.addEventHandler(this, "textarea1_change1");
  SoundCheck = new GCheckbox(this, 98, 304, 145, 20);
  SoundCheck.setTextAlign(GAlign.LEFT, GAlign.MIDDLE);
  SoundCheck.setText("Flash Lights to Music");
  SoundCheck.setOpaque(false);
  SoundCheck.addEventHandler(this, "checkbox1_clicked2");
  Reset = new GButton(this, 96, 344, 80, 30);
  Reset.setText("Reset Audio");
  Reset.addEventHandler(this, "button1_click1");
}

//GUI Objects
GTextField Hour; 
GTextField Minute; 
GDropList AM_PM; 
GCheckbox SleepCheck;
GTextArea TimerBox;
GCheckbox SoundCheck;
GButton Reset; 
void setup() {
  size(1000,800);//creates a window size 1000x600
  PFont font = createFont("arial",20);
   background(255,255,255);//sets background to white
   createGUI();
   tree= loadImage("tree.jpg");
   image(tree,400,0);
   minim=new Minim(this);//creates a new audio objecy
   in = minim.getLineIn(Minim.MONO,buffer_size,sample_rate);//creates an audio input
   fft = new FFT(in.bufferSize(), in.sampleRate());//creates a frequency analyzer
   fft.logAverages(16, 2);//create a smallest average frequency of 8
   fft.window(FFT.HAMMING);
   lastVal = new float[fft.avgSize()];
  //Intializing Arduino
  println(Arduino.list());
   arduino = new Arduino(this, Arduino.list()[0], 57600); //creates a new arduino object so it can communicate with the physical arduino
   println("Test");
  for (int i = 0; i <= 13; i++)
    arduino.pinMode(i, Arduino.OUTPUT);
    
}

void draw() {
      fft.forward(in.mix);//Steps forward int the audio
    if(SoundCheck.isSelected())
      audioActive=true;
     else audioActive=false;
    
     if(SleepCheck.isSelected())
       sleepActive=true;
      else {
        sleepActive=false;
        timerUp=false;
      }
      println(timerUp);
      if(audioActive&&!timerUp)
      audioAnalyze();
     if(sleepActive)
       sleepAnalyze();
       
    // Display the frame rate
    fill(16, 16, 16);
    if(!fullscreen)
    {
    frame.setTitle("Christmas Tree Lights");
    }

}
void audioAnalyze(){
  int iCount = fft.avgSize();//Number of Averages being calculated
    float biggestValChange = 0;//Biggest Change from pervious 
    
    for(int i = 0; i < iCount; i++) {//Loops through all the audio averages
      
      float iPercent = 1.0*i/iCount;//Percentage of Audio Analyzed
      
      float highFreqscale = 1.0 + pow(iPercent, 4) * 2.0;//Gets the Frequency Range of the current step
      
      float val = sqrt(fft.getAvg(i)) * valScale * highFreqscale / maxVisible; //gets the audio value of that frequency
      float valDiff = val-lastVal[i]; //gets the difference
      if(valDiff > beatThreshold && valDiff > biggestValChange) //checks if it is a big enough change and the most significant change
      {
        biggestValChange = valDiff;
      }
      
      lastVal[i] = val;

    }
    
    // If we've hit a beat, bring the brightness of the bar up to full
    if(biggestValChange > beatThreshold)
    {
      toggleOutput(0);
      print("Beat");
      if(bgYellow){
        background(255,255,255);
        bgYellow=false;
      }
       else {
         background(255,255,0);
         bgYellow=true;
       }
      image(tree,400,0);
    }
}
void sleepAnalyze(){
  setTime();
  int currentTime=timeToSeconds(hour(),minute(),second());
  println(currentTime);
  println(totalSeconds);
  int secondsLeft=totalSeconds-currentTime;
  if(secondsLeft<0)
    secondsLeft=0;
  int hoursLeft=secondsLeft/3600;
  int minutesLeft=secondsLeft%3600/60;
  secondsLeft=secondsLeft%3600%60;
  TimerBox.setText(hoursLeft+":"+minutesLeft+":"+secondsLeft);
  if(hoursLeft==0&&minutesLeft==0&&secondsLeft==0){
    for(int i=0;i<outputsTF.length;i++){
      if(outputsTF[i]){
        //toggleOutput(outputsTF[i]);
          bgYellow=false;
          background(255,255,255);
          sleepActive=false;
          image(tree,400,0);
          arduino.digitalWrite(outputs[i], low);
      } 
    }
    audioActive=false;
    timerUp=true;
    
    
  }
}
  int timeToSeconds(int hour, int minute, int second){
    return hour*3600+minute*60+second;
  }
  
void setTime(){
  int givenHour=Integer.parseInt(Hour.getText());
  int givenMinute=Integer.parseInt(Minute.getText());
  minute=givenMinute;
  if(AM_PM.getSelectedText().equals("PM")){
    hour=givenHour+12;
  }
  else hour=givenHour;
   totalSeconds=timeToSeconds(hour,minute,0);
}
void initLasts(){
  for(int i = 0; i < fft.avgSize(); i++) {
    lastVal[i] = 0;
  }
  
}
void stop(){//properly closes the program 
  in.close();
  minim.stop();
  super.stop();
}
void toggleOutput(int reference){ //toggles an output at a specfic spot in the outputs array
  
   if(outputsTF[reference]==false){
    outputsTF[reference]=true;
    arduino.digitalWrite(outputs[reference], high);
   }
  else if(outputsTF[reference]==true){
    outputsTF[reference]=false;
    arduino.digitalWrite(outputs[reference], low);
  }
    
    println("Test");
}


